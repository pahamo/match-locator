<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Broadcast Admin - Premier League TV Schedule</title>
  <style>
    :root {
      --color-border: #e5e7eb;
      --color-muted: #6b7280;
      --color-background: #f8fafc;
      --color-card: #ffffff;
      --color-text: #111827;
      --color-accent: #6366f1;
      --color-success: #10b981;
      --color-warning: #f59e0b;
      --border-radius: 8px;
      --spacing-sm: 8px;
      --spacing-md: 12px;
      --spacing-lg: 16px;
      --spacing-xl: 20px;
      --shadow-sm: 0 1px 3px rgba(0,0,0,.06), 0 6px 16px rgba(0,0,0,.04);
      --font-system: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; }
    
    body {
      font-family: var(--font-system);
      margin: 0;
      background: var(--color-background);
      color: var(--color-text);
      line-height: 1.5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--spacing-xl);
    }
    
    .header {
      background: var(--color-card);
      border-bottom: 1px solid var(--color-border);
      padding: var(--spacing-lg) 0;
      margin-bottom: var(--spacing-xl);
    }
    
    .header h1 {
      margin: 0;
      color: var(--color-text);
      font-size: 1.5rem;
    }
    
    .header p {
      margin: var(--spacing-sm) 0 0;
      color: var(--color-muted);
      font-size: 0.9rem;
    }
    
    .filter-bar {
      background: var(--color-card);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
      flex-wrap: wrap;
    }
    
    .filter-bar select {
      padding: var(--spacing-sm) var(--spacing-md);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-card);
    }
    
    .fixtures-table {
      background: var(--color-card);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      overflow: hidden;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    th, td {
      text-align: left;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--color-border);
    }
    
    th {
      background: var(--color-background);
      font-weight: 600;
      color: var(--color-text);
    }
    
    tr:last-child td {
      border-bottom: none;
    }
    
    .fixture-row:hover {
      background: #fafafa;
    }
    
    .match-info {
      font-weight: 500;
    }
    
    .match-time {
      font-size: 0.9rem;
      color: var(--color-muted);
    }
    
    .broadcast-editor {
      display: flex;
      gap: var(--spacing-sm);
      align-items: center;
    }
    
    .broadcast-select {
      padding: var(--spacing-sm);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-card);
      min-width: 120px;
    }
    
    .save-btn {
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--color-accent);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 0.8rem;
    }
    
    .save-btn:hover {
      background: #5046e4;
    }
    
    .save-btn:disabled {
      background: var(--color-muted);
      cursor: not-allowed;
    }
    
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: var(--spacing-sm);
    }
    
    .status-confirmed {
      background: var(--color-success);
    }
    
    .status-pending {
      background: var(--color-warning);
    }
    
    .status-blackout {
      background: #ef4444;
    }
    
    .status-none {
      background: var(--color-muted);
    }
    
    .loading {
      text-align: center;
      padding: var(--spacing-xl);
      color: var(--color-muted);
    }
    
    .error {
      background: #fee;
      border: 1px solid #fcc;
      color: #c33;
      padding: var(--spacing-md);
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing-lg);
    }
    
    .success {
      background: #efe;
      border: 1px solid #cfc;
      color: #363;
      padding: var(--spacing-md);
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing-lg);
    }
    
    .stats-bar {
      display: flex;
      gap: var(--spacing-lg);
      margin-bottom: var(--spacing-lg);
      font-size: 0.9rem;
      color: var(--color-muted);
    }
    
    .stats-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }
    
    .stats-card {
      background: var(--color-card);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      padding: var(--spacing-lg);
      text-align: center;
    }
    
    .stats-number {
      font-size: 2.5rem;
      font-weight: bold;
      margin-bottom: var(--spacing-sm);
    }
    
    .stats-number.confirmed { color: var(--color-success); }
    .stats-number.blackout { color: #ef4444; }
    .stats-number.pending { color: var(--color-warning); }
    .stats-number.total { color: var(--color-accent); }
    
    .stats-label {
      font-size: 0.9rem;
      color: var(--color-muted);
      font-weight: 500;
    }
    
    .month-stats {
      background: var(--color-background);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }
    
    .month-stats h3 {
      margin: 0 0 var(--spacing-sm);
      color: var(--color-text);
      font-size: 1.1rem;
    }
    
    .month-breakdown {
      display: flex;
      gap: var(--spacing-lg);
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="container">
      <h1>üé¨ Broadcast Admin</h1>
      <p>Manage UK broadcaster assignments for Premier League fixtures</p>
    </div>
  </div>

  <div class="container">
    <div id="message-area"></div>
    
    <div class="filter-bar">
      <label>Month:</label>
      <select id="month-filter">
        <option value="">All months</option>
        <!-- Options will be populated dynamically based on fixture data -->
      </select>
      
      <label>Status:</label>
      <select id="status-filter">
        <option value="">All fixtures</option>
        <option value="confirmed">Has broadcaster</option>
        <option value="blackout">Blackout</option>
        <option value="pending">Unknown</option>
      </select>
      
      <button onclick="loadFixtures()" class="save-btn">üîÑ Refresh</button>
      <button onclick="saveAllChanges()" class="save-btn" id="save-all-btn" style="background: var(--color-success);">üíæ Save All Changes</button>
    </div>
    
    <div class="stats-cards">
      <div class="stats-card">
        <div class="stats-number total" id="stats-total-number">0</div>
        <div class="stats-label">Total Fixtures</div>
      </div>
      <div class="stats-card">
        <div class="stats-number confirmed" id="stats-confirmed-number">0</div>
        <div class="stats-label">Confirmed</div>
      </div>
      <div class="stats-card">
        <div class="stats-number blackout" id="stats-blackout-number">0</div>
        <div class="stats-label">Blackout</div>
      </div>
      <div class="stats-card">
        <div class="stats-number pending" id="stats-pending-number">0</div>
        <div class="stats-label">Pending</div>
      </div>
    </div>

    <div class="month-stats" id="month-stats">
      <h3 id="current-month-title">Current Month</h3>
      <div class="month-breakdown">
        <span id="month-confirmed">Confirmed: 0</span>
        <span id="month-blackout">Blackout: 0</span>
        <span id="month-pending">Pending: 0</span>
        <span id="month-total">Total: 0</span>
      </div>
    </div>

    <div class="fixtures-table">
      <table>
        <thead>
          <tr>
            <th>Match</th>
            <th>Date & Time</th>
            <th>Status</th>
            <th>UK Broadcaster</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="fixtures-tbody">
          <tr>
            <td colspan="5" class="loading">Loading fixtures...</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <script>
    /** Supabase API configuration (copied from main app) */
    const SUPABASE_CONFIG = {
      url: 'https://nkfuzkrazehjivzmdrvt.supabase.co',
      anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5rZnV6a3JhemVoaml2em1kcnZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcyNjI5MzAsImV4cCI6MjA3MjgzODkzMH0.CNW1EUtcC4JWfDy-WzOIVDfv7rnXzsz1qqQyRTZVyXU'
    };
    
    const API_HEADERS = { 
      apikey: SUPABASE_CONFIG.anonKey, 
      Authorization: `Bearer ${SUPABASE_CONFIG.anonKey}` 
    };

    /** API endpoints (matching main app exactly) */
    const API_ENDPOINTS = {
      fixturesList: '/rest/v1/fixtures_with_teams',
      teams: '/rest/v1/teams',
      broadcasts: '/rest/v1/broadcasts',
      providers: '/rest/v1/providers'
    };

    /** Broadcaster options */
    const BROADCASTERS = [
      { id: '', name: 'Unknown', type: 'none' },
      { id: 1, name: 'Sky Sports', type: 'tv' },
      { id: 2, name: 'TNT Sports', type: 'tv' },
      { id: 3, name: 'BBC Sport', type: 'tv' },
      { id: 4, name: 'Amazon Prime Video', type: 'streaming' },
      { id: -1, name: 'üö´ Blackout (No TV)', type: 'blackout' }
    ];

    let allFixtures = [];
    let allTeams = {};
    let pendingChanges = new Map(); // Track pending changes: fixtureId -> providerId

    /** Check if fixture is marked as blackout in localStorage */
    function isFixtureBlackout(fixtureId) {
      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');
      return blackoutFixtures.includes(fixtureId);
    }

    /** Check if fixture has confirmed broadcaster */
    function isFixtureConfirmed(fixture) {
      return fixture.broadcast && fixture.broadcast.provider_id && !isFixtureBlackout(fixture.id);
    }

    /** Check if fixture is pending (no broadcaster and not blackout) */
    function isFixturePending(fixture) {
      return !fixture.broadcast && !isFixtureBlackout(fixture.id);
    }

    /** API helper function */
    async function apiGet(endpoint) {
      console.log('API GET:', `${SUPABASE_CONFIG.url}${endpoint}`);
      
      try {
        const response = await fetch(`${SUPABASE_CONFIG.url}${endpoint}`, {
          headers: API_HEADERS
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`API Error: ${response.status} ${response.statusText}`, errorText);
          console.error(`Failed URL: ${SUPABASE_CONFIG.url}${endpoint}`);
          throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
        }
        
        const data = await response.json();
        console.log('API Response:', data);
        return data;
      } catch (error) {
        console.error('API Request failed:', error);
        throw error;
      }
    }

    /** API POST/PATCH helper */
    async function apiWrite(endpoint, data, method = 'POST') {
      console.log(`API ${method}:`, `${SUPABASE_CONFIG.url}${endpoint}`, data);
      
      // Add Content-Type for write operations
      const writeHeaders = {
        ...API_HEADERS,
        'Content-Type': 'application/json'
      };
      
      try {
        const response = await fetch(`${SUPABASE_CONFIG.url}${endpoint}`, {
          method: method,
          headers: writeHeaders,
          body: JSON.stringify(data)
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
        }
        
        // Only parse JSON if there's content
        let result = null;
        const contentLength = response.headers.get('content-length');
        if (contentLength && contentLength !== '0') {
          try {
            result = await response.json();
          } catch (e) {
            // Response might be empty or not JSON, which is fine for PATCH/DELETE
            console.log('Response is not JSON, which is normal for PATCH/DELETE');
          }
        }
        
        console.log('API Write Response:', result);
        return result;
      } catch (error) {
        console.error('API Write failed:', error);
        throw error;
      }
    }

    /** Show message to user */
    function showMessage(text, type = 'success') {
      const messageArea = document.getElementById('message-area');
      messageArea.innerHTML = `<div class="${type}">${text}</div>`;
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        messageArea.innerHTML = '';
      }, 5000);
    }


    /** Replicate exact loadFixtures logic from main app */
    async function loadFixturesLikeMainApp(competitionId, includeUpcoming = true) {
      const nowIso = includeUpcoming ? new Date().toISOString() : null;
      const timeFilter = includeUpcoming ? `&utc_kickoff=gte.${nowIso}` : '';
      
      // Better filtering: only get fixtures from current season with valid matchdays
      const currentSeasonStart = '2024-08-01T00:00:00.000Z'; // Premier League 2024-25 season
      const seasonFilter = `&utc_kickoff=gte.${currentSeasonStart}`;
      const matchdayFilter = '&matchday=gte.1&matchday=lte.38'; // Valid PL matchdays
      
      const orderByKickoff = 'order=utc_kickoff.asc';
      const limit = 2000; // Same as main app
      
      const attempts = [
        // Primary: Current season fixtures with valid matchdays
        `${API_ENDPOINTS.fixturesList}?competition_id=eq.${competitionId}${timeFilter}${seasonFilter}${matchdayFilter}&${orderByKickoff}&limit=${limit}`,
        // Fallback: Current season fixtures without matchday constraint
        `${API_ENDPOINTS.fixturesList}?competition_id=eq.${competitionId}${timeFilter}${seasonFilter}&${orderByKickoff}&limit=${limit}`,
        // Fallback: All season fixtures with matchday constraint
        includeUpcoming ? `${API_ENDPOINTS.fixturesList}?competition_id=eq.${competitionId}${seasonFilter}${matchdayFilter}&${orderByKickoff}&limit=${limit}` : null,
        // Last resort: Basic query with just competition filter
        `${API_ENDPOINTS.fixturesList}?competition_id=eq.${competitionId}${timeFilter}&${orderByKickoff}&limit=${limit}`
      ].filter(Boolean);
      
      for (const endpoint of attempts) {
        try {
          console.log(`Trying fixtures endpoint: ${endpoint}`);
          const fixtures = await apiGet(endpoint);
          
          if (fixtures && fixtures.length > 0) {
            // Additional safety filter: exclude suspicious low-ID fixtures as backup
            const filtered = fixtures.filter(f => f.id && f.id > 30);
            const removedCount = fixtures.length - filtered.length;
            if (removedCount > 0) {
              console.log(`Successfully loaded ${fixtures.length} fixtures for competition ${competitionId}, filtered to ${filtered.length} (removed ${removedCount} low-ID fixtures)`);
            } else {
              console.log(`Successfully loaded ${filtered.length} valid fixtures for competition ${competitionId}`);
            }
            return filtered;
          }
        } catch (error) {
          console.log(`Fixtures endpoint failed: ${endpoint}`, error.message);
          continue;
        }
      }
      
      throw new Error(`Unable to load fixtures for competition ${competitionId} after trying ${attempts.length} endpoints`);
    }

    /** Load teams data - start with exact debug page query */
    async function loadTeams() {
      try {
        // Use exact same query as debug page
        const teams = await apiGet(`${API_ENDPOINTS.teams}?select=id,name,slug,competition_id&order=name.asc&limit=50`);
        
        // Create lookup object
        teams.forEach(team => {
          allTeams[team.id] = team;
        });
        
        console.log('Loaded teams:', Object.keys(allTeams).length);
      } catch (error) {
        console.error('Failed to load teams:', error);
        showMessage('Failed to load teams data', 'error');
      }
    }

    /** Load fixtures using same logic as main app */
    async function loadFixtures() {
      const tbody = document.getElementById('fixtures-tbody');
      tbody.innerHTML = '<tr><td colspan="5" class="loading">Loading fixtures...</td></tr>';
      
      try {
        // Load teams first if not loaded
        if (Object.keys(allTeams).length === 0) {
          await loadTeams();
        }

        // Use exactly the same loadFixtures logic as debug page
        const fixtures = await loadFixturesLikeMainApp(1, true); // Premier League ID = 1
        
        if (!fixtures || fixtures.length === 0) {
          throw new Error('No fixtures loaded');
        }
        
        console.log('Loaded fixtures:', fixtures.length);
        
        // Get all broadcast data for these fixtures
        const fixtureIds = fixtures.map(f => f.id);
        let broadcasts = [];
        
        if (fixtureIds.length > 0) {
          // Use same query as main app - no select clause to get all columns
          const broadcastsEndpoint = `${API_ENDPOINTS.broadcasts}?fixture_id=in.(${fixtureIds.join(',')})`;
          broadcasts = await apiGet(broadcastsEndpoint);
          console.log('Loaded broadcasts:', broadcasts.length);
        }
        
        // Create broadcast lookup
        const broadcastLookup = {};
        broadcasts.forEach(b => {
          broadcastLookup[b.fixture_id] = b;
        });
        
        // Store for filtering - no need for blackout markers, just use database data
        allFixtures = fixtures.map(fixture => ({
          ...fixture,
          broadcast: broadcastLookup[fixture.id] || null
        }));
        
        populateMonthSelector();
        renderFixtures();
        updateStats();
        
      } catch (error) {
        console.error('Failed to load fixtures:', error);
        showMessage('Failed to load fixtures: ' + error.message, 'error');
        tbody.innerHTML = '<tr><td colspan="5" class="error">Failed to load fixtures</td></tr>';
      }
    }

    /** Render fixtures table */
    function renderFixtures() {
      const tbody = document.getElementById('fixtures-tbody');
      const monthFilter = document.getElementById('month-filter').value;
      const statusFilter = document.getElementById('status-filter').value;
      
      // Apply filters
      let filteredFixtures = allFixtures;
      
      if (monthFilter) {
        filteredFixtures = filteredFixtures.filter(f => 
          f.utc_kickoff && f.utc_kickoff.startsWith(monthFilter)
        );
      }
      
      if (statusFilter === 'confirmed') {
        filteredFixtures = filteredFixtures.filter(f => isFixtureConfirmed(f));
      } else if (statusFilter === 'blackout') {
        filteredFixtures = filteredFixtures.filter(f => isFixtureBlackout(f.id));
      } else if (statusFilter === 'pending') {
        filteredFixtures = filteredFixtures.filter(f => isFixturePending(f));
      }
      
      if (filteredFixtures.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="loading">No fixtures found</td></tr>';
        return;
      }
      
      tbody.innerHTML = filteredFixtures.map(fixture => {
        const homeTeam = allTeams[fixture.home_team_id];
        const awayTeam = allTeams[fixture.away_team_id];
        const kickoffTime = new Date(fixture.utc_kickoff).toLocaleString('en-GB');
        
        const broadcast = fixture.broadcast;
        const currentProviderId = broadcast?.provider_id || '';
        
        // Status indicator
        const hasProvider = currentProviderId && currentProviderId !== '';
        const isBlackout = isFixtureBlackout(fixture.id);
        
        let statusClass, statusText;
        if (isBlackout) {
          statusClass = 'status-blackout';
          statusText = 'Blackout';
        } else if (hasProvider) {
          statusClass = 'status-confirmed';
          statusText = 'Confirmed';
        } else {
          statusClass = 'status-pending';
          statusText = 'Pending';
        }
        
        // Broadcaster select options - check blackout status from localStorage
        const selectOptions = BROADCASTERS.map(broadcaster => {
          let isSelected = false;
          if (broadcaster.id === '-1') {
            // Blackout option - check localStorage
            isSelected = isFixtureBlackout(fixture.id);
          } else {
            // Regular broadcaster - check database
            isSelected = currentProviderId == broadcaster.id;
          }
          
          return `<option value="${broadcaster.id}" ${isSelected ? 'selected' : ''}>
            ${broadcaster.name}
          </option>`;
        }).join('');
        
        return `
          <tr class="fixture-row">
            <td class="match-info">
              ${homeTeam?.name || 'Team ' + fixture.home_team_id} vs 
              ${awayTeam?.name || 'Team ' + fixture.away_team_id}
            </td>
            <td>
              <div>${kickoffTime}</div>
              <div class="match-time">Matchday ${fixture.matchday || 'N/A'}</div>
            </td>
            <td>
              <span class="status-indicator ${statusClass}"></span>
              ${statusText}
            </td>
            <td>
              <div class="broadcast-editor">
                <select class="broadcast-select" id="provider-${fixture.id}" onchange="trackChange(${fixture.id})">
                  ${selectOptions}
                </select>
              </div>
            </td>
            <td>
              <button class="save-btn" onclick="saveBroadcast(${fixture.id})" id="save-${fixture.id}">
                Save
              </button>
              <span class="pending-indicator" id="pending-${fixture.id}" style="display:none; color: var(--color-warning); font-size: 0.8rem; margin-left: 4px;">‚óè</span>
            </td>
          </tr>
        `;
      }).join('');
    }

    /** Save broadcast assignment */
    async function saveBroadcast(fixtureId) {
      const saveBtn = document.getElementById(`save-${fixtureId}`);
      const providerSelect = document.getElementById(`provider-${fixtureId}`);
      const providerId = providerSelect.value;
      
      saveBtn.textContent = 'Saving...';
      saveBtn.disabled = true;
      
      try {
        await saveBroadcastInternal(fixtureId, providerId);
        
        // Remove from pending changes and hide indicator
        pendingChanges.delete(fixtureId);
        document.getElementById(`pending-${fixtureId}`).style.display = 'none';
        updateSaveAllButton();
        
        // Show success message
        if (providerId == '-1') {
          showMessage(`Set fixture ${fixtureId} as blackout (no TV)`, 'success');
        } else if (providerId === '' || providerId === '0') {
          showMessage(`Removed broadcaster for fixture ${fixtureId}`, 'success');
        } else {
          const broadcasterName = BROADCASTERS.find(b => b.id == providerId)?.name || 'Unknown';
          showMessage(`Set broadcaster to ${broadcasterName} for fixture ${fixtureId}`, 'success');
        }
        
        // Re-render to show updated status
        renderFixtures();
        updateStats();
        
      } catch (error) {
        console.error('Failed to save broadcast:', error);
        showMessage('Failed to save: ' + error.message, 'error');
      } finally {
        saveBtn.textContent = 'Save';
        saveBtn.disabled = false;
      }
    }

    /** Get default channel for broadcaster */
    function getBroadcasterChannel(providerId) {
      const channels = {
        '1': 'Sky Sports Premier League',
        '2': 'TNT Sports',
        '3': 'BBC One',
        '4': 'Amazon Prime Video'
      };
      return channels[providerId] || null;
    }

    /** Update statistics display based on current selection */
    function updateStats() {
      // Get currently filtered fixtures (same as what's shown in table)
      const monthFilter = document.getElementById('month-filter').value;
      const statusFilter = document.getElementById('status-filter').value;
      
      let filteredFixtures = allFixtures;
      
      // Apply same filters as renderFixtures()
      if (monthFilter) {
        filteredFixtures = filteredFixtures.filter(f => 
          f.utc_kickoff && f.utc_kickoff.startsWith(monthFilter)
        );
      }
      
      if (statusFilter === 'confirmed') {
        filteredFixtures = filteredFixtures.filter(f => isFixtureConfirmed(f));
      } else if (statusFilter === 'blackout') {
        filteredFixtures = filteredFixtures.filter(f => isFixtureBlackout(f.id));
      } else if (statusFilter === 'pending') {
        filteredFixtures = filteredFixtures.filter(f => isFixturePending(f));
      }
      
      // Calculate stats for filtered fixtures
      const total = filteredFixtures.length;
      const confirmed = filteredFixtures.filter(f => isFixtureConfirmed(f)).length;
      const blackout = filteredFixtures.filter(f => isFixtureBlackout(f.id)).length;
      const pending = total - confirmed - blackout;
      
      // Update main stats cards
      document.getElementById('stats-total-number').textContent = total;
      document.getElementById('stats-confirmed-number').textContent = confirmed;
      document.getElementById('stats-blackout-number').textContent = blackout;
      document.getElementById('stats-pending-number').textContent = pending;
      
      // Update current month stats
      const currentMonth = getCurrentMonth();
      const monthFixtures = allFixtures.filter(f => 
        f.utc_kickoff && f.utc_kickoff.startsWith(currentMonth)
      );
      
      const monthTotal = monthFixtures.length;
      const monthConfirmed = monthFixtures.filter(f => isFixtureConfirmed(f)).length;
      const monthBlackout = monthFixtures.filter(f => isFixtureBlackout(f.id)).length;
      const monthPending = monthTotal - monthConfirmed - monthBlackout;
      
      const monthName = new Date(currentMonth + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
      document.getElementById('current-month-title').textContent = `${monthName} Breakdown`;
      document.getElementById('month-total').textContent = `Total: ${monthTotal}`;
      document.getElementById('month-confirmed').textContent = `Confirmed: ${monthConfirmed}`;
      document.getElementById('month-blackout').textContent = `Blackout: ${monthBlackout}`;
      document.getElementById('month-pending').textContent = `Pending: ${monthPending}`;
    }

    /** Get current month in YYYY-MM format */
    function getCurrentMonth() {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      return `${year}-${month}`;
    }

    /** Populate month selector based on actual fixture data */
    function populateMonthSelector() {
      const monthSelect = document.getElementById('month-filter');
      const currentSelection = monthSelect.value; // Preserve current selection
      
      // Extract unique months from fixture data
      const months = new Set();
      allFixtures.forEach(fixture => {
        if (fixture.utc_kickoff) {
          const monthKey = fixture.utc_kickoff.substring(0, 7); // Extract YYYY-MM
          months.add(monthKey);
        }
      });
      
      // Sort months chronologically
      const sortedMonths = Array.from(months).sort();
      
      // Clear existing options except "All months"
      monthSelect.innerHTML = '<option value="">All months</option>';
      
      // Add month options
      sortedMonths.forEach(monthKey => {
        const date = new Date(monthKey + '-01');
        const monthName = date.toLocaleDateString('en-US', { 
          month: 'long', 
          year: 'numeric' 
        });
        
        const option = document.createElement('option');
        option.value = monthKey;
        option.textContent = monthName;
        
        // Restore selection if it was previously selected
        if (monthKey === currentSelection) {
          option.selected = true;
        }
        
        monthSelect.appendChild(option);
      });
      
      console.log(`Populated month selector with ${sortedMonths.length} months:`, sortedMonths);
    }

    /** Track changes when dropdown changes */
    function trackChange(fixtureId) {
      const select = document.getElementById(`provider-${fixtureId}`);
      const newProviderId = select.value;
      const fixture = allFixtures.find(f => f.id === fixtureId);
      const currentProviderId = fixture?.broadcast?.provider_id || '';
      
      // Check if this is actually a change
      if (newProviderId != currentProviderId) {
        pendingChanges.set(fixtureId, newProviderId);
        document.getElementById(`pending-${fixtureId}`).style.display = 'inline';
      } else {
        pendingChanges.delete(fixtureId);
        document.getElementById(`pending-${fixtureId}`).style.display = 'none';
      }
      
      // Update Save All button visibility
      updateSaveAllButton();
    }

    /** Update Save All button state */
    function updateSaveAllButton() {
      const saveAllBtn = document.getElementById('save-all-btn');
      const hasChanges = pendingChanges.size > 0;
      
      if (hasChanges) {
        saveAllBtn.style.display = 'inline-block';
        saveAllBtn.textContent = `üíæ Save All (${pendingChanges.size})`;
      } else {
        saveAllBtn.style.display = 'none';
      }
    }

    /** Save all pending changes */
    async function saveAllChanges() {
      if (pendingChanges.size === 0) {
        showMessage('No changes to save', 'error');
        return;
      }
      
      const saveAllBtn = document.getElementById('save-all-btn');
      saveAllBtn.disabled = true;
      saveAllBtn.textContent = 'Saving...';
      
      let successCount = 0;
      let errorCount = 0;
      
      // Process each change
      for (const [fixtureId, providerId] of pendingChanges.entries()) {
        try {
          await saveBroadcastInternal(parseInt(fixtureId), providerId);
          pendingChanges.delete(fixtureId);
          document.getElementById(`pending-${fixtureId}`).style.display = 'none';
          successCount++;
        } catch (error) {
          console.error(`Failed to save fixture ${fixtureId}:`, error);
          errorCount++;
        }
      }
      
      // Show result message
      if (errorCount === 0) {
        showMessage(`Successfully saved ${successCount} changes`, 'success');
      } else {
        showMessage(`Saved ${successCount} changes, ${errorCount} failed`, 'error');
      }
      
      // Re-render and update UI
      renderFixtures();
      updateStats();
      updateSaveAllButton();
      
      saveAllBtn.disabled = false;
    }

    /** Extract save logic for reuse */
    async function saveBroadcastInternal(fixtureId, providerId) {
      const fixture = allFixtures.find(f => f.id === fixtureId);
      const existingBroadcast = fixture?.broadcast;
      
      if (providerId === '' || providerId === '0' || providerId === '-1') {
        // Remove broadcaster or set as blackout - delete record if exists
        if (existingBroadcast) {
          await apiWrite(
            `${API_ENDPOINTS.broadcasts}?fixture_id=eq.${fixtureId}`,
            {},
            'DELETE'
          );
        }
        
        // Update local data
        fixture.broadcast = null;
        
        // Store blackout flag in localStorage for admin UI tracking
        if (providerId === '-1') {
          const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');
          if (!blackoutFixtures.includes(fixtureId)) {
            blackoutFixtures.push(fixtureId);
            localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));
          }
        } else {
          // Remove from blackout list if setting to empty
          const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');
          const updatedBlackout = blackoutFixtures.filter(id => id !== fixtureId);
          localStorage.setItem('blackoutFixtures', JSON.stringify(updatedBlackout));
        }
        
      } else {
        // Add/update broadcaster - remove from blackout list first
        const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');
        const updatedBlackout = blackoutFixtures.filter(id => id !== fixtureId);
        localStorage.setItem('blackoutFixtures', JSON.stringify(updatedBlackout));
        const broadcastData = {
          fixture_id: fixtureId,
          provider_id: parseInt(providerId)
        };
        
        if (existingBroadcast) {
          // Update existing
          await apiWrite(
            `${API_ENDPOINTS.broadcasts}?fixture_id=eq.${fixtureId}`,
            broadcastData,
            'PATCH'
          );
          
          // Update local data
          Object.assign(fixture.broadcast, broadcastData);
        } else {
          // Create new
          await apiWrite(API_ENDPOINTS.broadcasts, broadcastData, 'POST');
          
          // Update local data
          fixture.broadcast = broadcastData;
        }
      }
    }

    /** Event listeners */
    document.getElementById('month-filter').addEventListener('change', () => {
      renderFixtures();
      updateStats(); // Update stats when filter changes
    });
    document.getElementById('status-filter').addEventListener('change', () => {
      renderFixtures();
      updateStats(); // Update stats when filter changes  
    });


    /** Initialize app */
    async function init() {
      console.log('Initializing Broadcast Admin...');
      updateSaveAllButton(); // Hide Save All button initially
      await loadFixtures();
    }

    // Start the app
    init();
  </script>
</body>
</html>